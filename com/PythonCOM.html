
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Python and COM - Implementation Details &#8212; pywin32 305 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/sphinx_highlight.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Misc stuff I don’t know where to put anywhere else" href="misc.html" />
    <link rel="prev" title="The win32com package" href="package.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p><img alt="Python and COM, Blowing the rest away" src="../_images/pycom_blowing.gif" /></p>
<section id="python-and-com-implementation-details">
<h1>Python and COM - Implementation Details<a class="headerlink" href="#python-and-com-implementation-details" title="Permalink to this heading">¶</a></h1>
<div class="admonition-existing-document admonition">
<p class="admonition-title">Existing document</p>
<p><code class="file docutils literal notranslate"><span class="pre">\com\win32com\html\PythonCOM.html</span></code></p>
</div>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#general-com-support" id="id1">General COM Support</a></p></li>
<li><p><a class="reference internal" href="#naming-conventions" id="id2">Naming Conventions</a></p></li>
<li><p><a class="reference internal" href="#core-com-support" id="id3">Core COM support</a></p></li>
<li><p><a class="reference internal" href="#com-structures-and-python-types" id="id4">COM Structures and Python Types</a></p></li>
<li><p><a class="reference internal" href="#com-framework" id="id5">COM Framework</a></p></li>
</ul>
</nav>
<p>Introduction</p>
<p>This document describes the technical implementation of the COM support in Python. It is primarily concerned with the underlying C++ interface to COM, although general Python issues are touched.</p>
<p>This document is targeted at people who wish to maintain/enhance the standard COM support (typically by writing extension modules). For information on using Python and COM from a Python programmers perspective, please see the documentation index.</p>
<section id="general-com-support">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">General COM Support</a><a class="headerlink" href="#general-com-support" title="Permalink to this heading">¶</a></h2>
<p>COM support in Python can be broken into 2 general areas - C++ support, and Python support. C++ support exists in the core PythonCOM module (plus any PythonCOM extension modules). Python support exists in the .py files that accompany the core module.</p>
</section>
<section id="naming-conventions">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">Naming Conventions</a><a class="headerlink" href="#naming-conventions" title="Permalink to this heading">¶</a></h2>
<p>The naming conventions used by Python code will be:</p>
<ul class="simple">
<li><p>The Python “New Import” (ni) module will be used, allowing packages, or nested modules.</p></li>
<li><p>The package name will be “win32com”.</p></li>
<li><p>The core module name will be “pythoncom” (ie, “win32com.pythoncom”)</p></li>
<li><p>The rest of the naming conventions are yet to be worked out.</p></li>
</ul>
</section>
<section id="core-com-support">
<h2><a class="toc-backref" href="#id3" role="doc-backlink">Core COM support</a><a class="headerlink" href="#core-com-support" title="Permalink to this heading">¶</a></h2>
<p>This section is involved with the core C++ support in “pythoncom”.</p>
<p>The organisation of PythonCOM support falls into 3 discrete areas.</p>
<section id="com-client-support">
<h3>COM Client Support<a class="headerlink" href="#com-client-support" title="Permalink to this heading">¶</a></h3>
<p>This is the ability to manipulate other COM objects via their exposed interface. This includes use of IDispatch (eg using Python to start Microsoft Word, open a file, and print it.) but also all client side IUnknown derived objects fall into this category, including ITypeLib and IConnectionPoint support.</p>
</section>
<section id="com-server-support">
<h3>COM Server Support<a class="headerlink" href="#com-server-support" title="Permalink to this heading">¶</a></h3>
<p>This is ability for Python to create COM Servers, which can be manipulated by another COM client. This includes server side IDispatch (eg, Visual Basic starting a Python interpreter, and asking it to evaluate some code) but also all supported server side IUnknown derived classes.</p>
</section>
<section id="python-com-type-and-value-conversion">
<h3>Python/COM type and value conversion<a class="headerlink" href="#python-com-type-and-value-conversion" title="Permalink to this heading">¶</a></h3>
<p>This is internal code used by the above areas to managed the conversion to and from Python/COM types and values. This includes code to convert an arbitrary Python object into a COM variant, manages return types, and a few other helpers.</p>
</section>
</section>
<section id="com-structures-and-python-types">
<h2><a class="toc-backref" href="#id4" role="doc-backlink">COM Structures and Python Types</a><a class="headerlink" href="#com-structures-and-python-types" title="Permalink to this heading">¶</a></h2>
<p>OLE supports many C level structures for the COM API, which must be mapped to Python.</p>
<section id="variant">
<h3>VARIANT<a class="headerlink" href="#variant" title="Permalink to this heading">¶</a></h3>
<p>Variants are never exposed as such to Python programs. The internal framework always converts all variants to and from Python types. In some cases, type descriptions may be used, which force specific mappings, although in general the automatic conversion works fine.</p>
</section>
<section id="typedesc">
<h3>TYPEDESC<a class="headerlink" href="#typedesc" title="Permalink to this heading">¶</a></h3>
<p>A tuple, containing the elements of the C union. This union will be correctly decoded by the support code.</p>
</section>
<section id="elemdesc">
<h3>ELEMDESC<a class="headerlink" href="#elemdesc" title="Permalink to this heading">¶</a></h3>
<p>A tuple of TYPEDESC and PARAMDESC objects.</p>
</section>
<section id="funcdesc">
<h3>FUNCDESC<a class="headerlink" href="#funcdesc" title="Permalink to this heading">¶</a></h3>
<p>A funcdesc is a large and unwieldy tuple. Documentation to be supplied.</p>
</section>
<section id="iid-clsid">
<h3>IID/CLSID<a class="headerlink" href="#iid-clsid" title="Permalink to this heading">¶</a></h3>
<p>A native IID in Python is a special type, defined in pythoncom. Whenever a CLSID/IID is required, typically either an object, a tuple of type “iii(iiiiiiii)” or string can be used.</p>
<p>Helper functions are available to convert to and from IID/CLSID and strings.</p>
</section>
</section>
<section id="com-framework">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">COM Framework</a><a class="headerlink" href="#com-framework" title="Permalink to this heading">¶</a></h2>
<p>Both client and server side support have a specific framework in place to assist in supporting the widest possible set of interfaces. The framework allows external extension DLLs to be written, which extend the interfaces available to the Python user.</p>
<p>This allows the core PythonCOM module to support a wide set of common interfaces, and other extensions to support anything obscure.</p>
<section id="client-framework">
<h3>Client Framework<a class="headerlink" href="#client-framework" title="Permalink to this heading">¶</a></h3>
<section id="queryinterface-and-types">
<h4>QueryInterface and Types<a class="headerlink" href="#queryinterface-and-types" title="Permalink to this heading">¶</a></h4>
<p>When the only support required by Python is IDispatch, everything is simple - every object returned from QueryInterface is a PyIDispatch object. But this does not extend to other types, such as ITypeLib, IConnectionPoint etc., which are required for full COM support.</p>
<p>For example, consider the following C++ psuedo-code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>IConnectionPoint *conPt;
someIDispatch-&gt;QueryInterface(IID_IConnectionPoint, (void **)&amp;conPt);
// Note the IID_ and type of the * could be anything!
</pre></div>
</div>
<p>This cast, and knowledge of a specific IID_* to type must be simulated in Python.</p>
<p>Python/COM will therefore maintain a map of UID’s to Python type objects. Whenever QueryInterface is called, Python will lookup this map, to determine if the object type is supported. If the object is supported, then an object of that type will be returned. If the object is not supported, then a PyIUnknown object will be returned.</p>
<p>Note that PyIDispatch will be supported by the core engine. Therefore:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">disp</span><span class="o">=</span><span class="n">someobj</span><span class="o">.</span><span class="n">QueryInterface</span><span class="p">(</span><span class="n">win32com</span><span class="o">.</span><span class="n">IID_Dispatch</span><span class="p">)</span>
</pre></div>
</div>
<p>will return a PyIDispatch object, whereas</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">unk</span><span class="o">=</span><span class="n">someobj</span><span class="o">.</span><span class="n">QueryInterface</span><span class="p">(</span><span class="n">SomeUnknownIID</span><span class="p">)</span> <span class="c1"># returns PyIUnknown</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">disp</span><span class="o">=</span><span class="n">unk</span><span class="o">.</span><span class="n">QueryInterface</span><span class="p">(</span><span class="n">win32com</span><span class="o">.</span><span class="n">IID_Dispatch</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unk</span><span class="o">.</span><span class="n">Release</span><span class="p">()</span> <span class="c1"># Clean up now, rather than waiting for unk death.</span>
</pre></div>
</div>
<p>Is needed to convert to an IDispatch object.</p>
</section>
<section id="core-support">
<h4>Core Support<a class="headerlink" href="#core-support" title="Permalink to this heading">¶</a></h4>
<p>The core COM support module will support the IUnknown, IDispatch, ITypeInfo, ITypeLib and IConnectionPointContainer and IConnectionPoint interfaces. This implies the core COM module supports 6 different OLE client object types, mapped to the 6 IID_*’s representing the objects. (The IConnection* objects allow for Python to repsond to COM events)</p>
<p>A psuedo-inheritance scheme is used. The Python types are all derived from the Python IUnknown type (PyIUnknown). Therefore all IUnknown methods are automatically available to all types, just as it should be. The PyIUnknown type manages all object reference counts and destruction.</p>
</section>
<section id="extensibility">
<h4>Extensibility<a class="headerlink" href="#extensibility" title="Permalink to this heading">¶</a></h4>
<p>To provide the above functionality, a Python map is provided, which maps from a GUID to a Python type object.</p>
<p>The advantage of this scheme is an external extension modules can hook into the core support. For example, imagine the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">myextracom</span> <span class="c1"># external .pyd supporting some interface.</span>
<span class="go"># myextracom.pyd will do the equivilent of</span>

<span class="go"># pythoncom.mapSupportedTypes(myextracom.IID_Extra, myextracom.ExtraType)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">someobj</span><span class="o">.</span><span class="n">QueryInterface</span><span class="p">(</span><span class="n">myextracom</span><span class="o">.</span><span class="n">IID_Extra</span><span class="p">)</span>
</pre></div>
</div>
<p>Would correctly return an object defined in the extension module.</p>
</section>
</section>
<section id="server-framework">
<h3>Server Framework<a class="headerlink" href="#server-framework" title="Permalink to this heading">¶</a></h3>
<section id="general-framework">
<h4>General Framework<a class="headerlink" href="#general-framework" title="Permalink to this heading">¶</a></h4>
<p>A server framework has been put in place which provides the following features:</p>
<p>All Interfaces provide VTBL support - this means that the Servers exposed by Python are callable from C++ and other compiled languages.</p>
<p>Supports full “inproc” servers. This means that no external .EXE is needed making Python COM servers available in almost all cases.</p>
<p>An extensible model which allows for extension modules to provide server support for interfaces defined in that module. A map is provided which maps from a GUID to a function pointer which creates the interface.</p>
</section>
<section id="python-and-variant-types-conversion">
<h4>Python and Variant Types Conversion<a class="headerlink" href="#python-and-variant-types-conversion" title="Permalink to this heading">¶</a></h4>
<p>In general, Python and COM are both “type-less”. COM is type-less via the VARIANT object, which supports many types, and Python is type-less due to its object model.</p>
<p>There are a number of areas where Python and OLE clash.</p>
</section>
<section id="parameters-and-conversions">
<h4>Parameters and conversions<a class="headerlink" href="#parameters-and-conversions" title="Permalink to this heading">¶</a></h4>
<p>For simple calls, there are 2 helpers available which will convert to and from PyObjects and VARIANTS. The call to convert a Python object to a VARIANT is simple in that it returns a VARIANT of the most appropriate type for the Python object - ie, the type of the Python object determines the resulting VARIANT type.</p>
<p>There are also more complex conversion routines available, wrapped in a C++ helper class. Typically, these helpers are used whenever a specific variant type is known (eg, when an ITypeInfo is available for the object being used). In this case, all efforts are made to convert the Python type to the requested variant type - ie, in this situation, the VARIANT type determines how the Python object is coerced. In addition, this code supports the use of “ByRef” and pointer paramaters, providing and freeing any buffers necessary for the call.</p>
</section>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">pywin32</a></h1>



<p class="blurb">Python for Windows Extensions</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=mhammond&repo=pywin32&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../gettingstarted.html">Getting Started Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../win32/index.html">Win32 Extensions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">PythonCOM</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="QuickStartClientCom.html">Client-side COM</a></li>
<li class="toctree-l2"><a class="reference internal" href="QuickStartServerCom.html">Server-side COM</a></li>
<li class="toctree-l2"><a class="reference internal" href="GeneratedSupport.html">Generated COM</a></li>
<li class="toctree-l2"><a class="reference internal" href="variant.html">VARIANT</a></li>
<li class="toctree-l2"><a class="reference internal" href="package.html">win32com</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Python &amp; COM</a></li>
<li class="toctree-l2"><a class="reference internal" href="misc.html">Miscellany</a></li>
<li class="toctree-l2"><a class="reference internal" href="active_directory.html">Active Directory</a></li>
<li class="toctree-l2"><a class="reference internal" href="adsi.html">ADSI &amp; Exchange</a></li>
<li class="toctree-l2"><a class="reference internal" href="asp.html">ASP and Python</a></li>
<li class="toctree-l2"><a class="reference internal" href="cpp.html">Python, C++, and COM</a></li>
<li class="toctree-l2"><a class="reference internal" href="mts.html">MTS and Python for NT</a></li>
<li class="toctree-l2"><a class="reference internal" href="shell.html">win32com.shell</a></li>
<li class="toctree-l2"><a class="reference internal" href="directsound.html">DirectSound examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="samples/index.html">Samples</a></li>
<li class="toctree-l2"><a class="reference internal" href="apidoc/index.html">API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../adodbapi/index.html">ADO DB-API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../isapi/index.html">ISAPI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Pythonwin/index.html"> Pythonwin</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SWIG/index.html">SWIG</a></li>
<li class="toctree-l1"><a class="reference internal" href="../support.html">Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../resources.html">Resources</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Mark Hammond.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.3.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/com/PythonCOM.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>